#Java内存模型
  问：在Java并发编程中， 多线程之间采取什么机制进行线程间的通信？采取什么机制进行数据的同步？  
  答：Java并发采用共享内存模型来实现信息交换和数据同步的。
  
线程之间通过共享程序公共的状态，通过读-写内存中公共状态的方式来进行隐式的通信。同步指的是程序在控制多个线程之间执行程序的相对顺序的机制，
在共享内存模型中，同步是显式的，程序员必须显式指定某个方法/代码块需要在多线程之间互斥执行。

##主内存和工作内存
JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的
变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作
内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，
线程之间值的传递都需要通过主内存来完成。

　　线程1和线程2要想进行数据的交换一般要经历下面的步骤：

　　1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。

　　2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。
  
  ### Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的
  1.原子性（Atomicity）：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行
    该操作之前的状态。
  
  2.　可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。
  
  3.有序性：对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；
    但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，
    所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存
    和主内存同步延迟”现象。

    Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，
    而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，

    在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。
