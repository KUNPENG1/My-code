数据库隔离级别
     
	事务四大特性
     1.原子性：事务必须是原子单元，不可有子集。事务的操作要么全部执行，要么全部不执行。

     2.一致性：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。举例，A\B两人共有10块，那么他们不管进行什么操作，他们的钱加起来必须是100。

     3.隔离性：一个事务与跟它并发的事务所做的修改隔离。

     4.持久性：事务对数据库的操作是永久性的。


    事务并发控制
     1.第一类丢失更新：count = 100，两个事务同时对它更新，一开始都读取到100，此时A事务更新到101，B事务由于某种原因失败回滚，将count回滚到100，A的更新丢失了。

     2.第二类丢失更新：count = 100，两个事务同时对它更新，一开始都读取到100，此时A事务更新到101，B事务也是从100更新到101。由于B事务还是从100增加，A事务的更新丢失了。

     3.脏读：A事务读取到了B事务更新但未提交的数据。count = 100。A事务将其更新为101，此时B事务读取count = 101，但A事务失败回滚，count = 100，B事务出现脏读。

     4.不可重复读：一个事务不能重复读取一个数据，因为有可能在重复读的过程中，这个数据发生了修改，导致读取结果不一致。

     5.幻读：类似不可重复读。但是幻读针对数据的条数。
	 
 
    数据库隔离级别

     1.读未提交:安全性低，基本不用。
 
     2.读已提交：Oracle、Sqlserver

     3.可重复读:MySQL

     4.串行化：效率太低基本不用。
	 spring事务管理加了一个默认，表示默认使用数据库的隔离级别·
	 
	各种隔离级别对各异常的控制能力：
	
	
	数据库锁分类：分为悲观锁和乐观锁，悲观锁是我们通常说的数据库锁机制，乐观锁一般是指由用户自己实现的一种锁机制。
	 1.悲观锁：认为数据会随时修改，所以整个数据处理过程都会将数据加锁。悲观锁一般都是依靠关系数据库的锁机制，关系数据库中的行锁，表锁，读写锁都是悲观锁。
	 
	   （1）共享锁（S锁）：也称读锁，事务A对对象T加S锁，其他事务也只能对T加S锁。多个事务可以同时读，但是不能有写操作。直到事务A释放S锁。
	   
	   （2）排它锁（X锁）：也称写锁，事务A对对象T加X锁，其他事务不能对T加任何锁，只有事务A可以读写对象T，直到A释放X锁。
	   
	   （3）更新锁（U锁）：用来预定对此页加X锁，允许其他事务读，但不允许再加X锁或U锁，当被读取的页将要更新时，则升级为X锁，U锁直到事务结束才释放。
	   
	   
	 2.乐观锁：每次操作数据的时候不认为数据会发生修改，但在更新时会判断在此期间数据是否发生修改。如果修改了，返回给用户错误信息，让用户决定如何做。
	 实现方式：
	 （1）版本号（version）:为数据增加一个version字段，每次更新给这个字段+1。读取数据的同时把version读出来，更新的时候比较数据库表当前version与我们第一次
	  取出来的是否一致，如果一致则更新，如果不一致返回无法更新的通知给用户
	  
	 （2）时间戳（timestamp）：和版本号基本一样，只是使用时间戳判断。注意时间戳使用数据库时间而不是业务系统时间。
	 
	 （3）待更新字段：和版本号相似，区别是不增加额外字段。假如数据库有个字段count，更新的时候拿数据库中count的值与我们之前读到的比较，一致则更新，不一致失效。
	 
	 （4）所有字段：和版本号相似，区别是用所有字段做版本控制。
	 
	 现在我们介绍避免死锁的几个常见方法。
·避免一个线程同时获取多个锁。
·避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
·尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
·对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
	 
	 
Spring的事务传播特性
     传播行为：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。

　　Spring 定义了如下七中传播行为，这里以A业务和B业务之间如何传播事务为例说明：

　　①、PROPAGATION_REQUIRED ：required , 必须。默认值，A如果有事务，B将使用该事务；如果A没有事务，B将创建一个新的事务。

　　②、PROPAGATION_SUPPORTS：supports ，支持。A如果有事务，B将使用该事务；如果A没有事务，B将以非事务执行。

　　③、PROPAGATION_MANDATORY：mandatory ，强制。A如果有事务，B将使用该事务；如果A没有事务，B将抛异常。

　　④、PROPAGATION_REQUIRES_NEW ：requires_new，必须新的。如果A有事务，将A的事务挂起，B创建一个新的事务；如果A没有事务，B创建一个新的事务。

　　⑤、PROPAGATION_NOT_SUPPORTED ：not_supported ,不支持。如果A有事务，将A的事务挂起，B将以非事务执行；如果A没有事务，B将以非事务执行。

　　⑥、PROPAGATION_NEVER ：never，从不。如果A有事务，B将抛异常；如果A没有事务，B将以非事务执行。

　　⑦、PROPAGATION_NESTED ：nested ，嵌套。A和B底层采用保存点机制，形成嵌套事务。

Spring 编程式事务和声明式事务的区别　
　　编程式事务处理：所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。
                    管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。

　　声明式事务处理：管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，
                    在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，
					这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，
					便可以将事务规则应用到业务逻辑中。

　　简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。
	
	
	
	
	
	
	
	
	
	
	 
	 
