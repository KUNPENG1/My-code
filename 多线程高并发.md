## 1.线程和进程的区别
* （1）进程：进程是计算机的运行实例，包含了要执行的指令，有自己的独立空间，包含程序内容和数据，不同进程的空间地址是隔离的。
* （2）线程：程序的执行流程，CPU调度执行的最小单位，有自己的程序计数器、寄存器、堆栈和帧，同一进程中的线程共有内存空间。


## 2.线程的使用和线程的生命周期
  * （1）继承Thread类
  * （2）实现Runnable接口
  * （3）FutureTask /Callable （带返回值） 实现Callable接口，然后将Callable作为任务提交给FutureTask
	 
	 面试题：接口实现和继承Thread类那种方式好一点？
	     答：1.接口实现好点，因为Java不支持多继承，因此继承了Thread就无法继承其他类，但java可以实现多个接口。
		     2.可能只要求能够执行就好，继承整个Thread开销太大。
		  
## 3.线程的状态
  * 新建（New） 创建后未启动
	 
  * 可运行（Runnable） 可能在运行，也可能正在等待CPU时间片。包含操作系统中的Running和Ready两种状态。
	 
  * 阻塞（Blocking） 等待获取一个排它锁，其他线程释放了锁就会结束 
	 
  * 无限期等待（Waiting） 等待其他线程显式唤醒
	 
	 
 ## 3.synchronized关键字和volatile详解  （wait/noifty）
 * (1)、锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。
      * 互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。
      * 可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，         线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。（竞态条件）

 * （2）、在Java中,为了保证多线程读写数据时保证数据的一致性,可以采用两种方式：
      * 同步：如用synchronized关键字,或者使用锁对象
      * 使用volatile关键字：用一句话概括volatile,它能够使变量在值发生改变时能尽快地让其他线程知道。

 * （3）、volatile详解
  * 当一个变量定义为volatile后，它将具备两种特性：1. 可见性，2. 禁止指令重排序。

  * 首先，我们要意识到有这样的现象：编译器为了加快程序运行速度，对一些变量的写操作会现在寄存器或CPU缓存上进行，最后写入内存。
而在这个过程中，变量的新值对其它线程是不可见的。
  
  * 可见性：当对volatile标记的变量进行修改时，会将其它缓存中存储的修改前的变量清除，然后重新读取。这里从哪读尚未明确，一般来说
应该是先在进行修改的缓存A中修改为新值，然后通知其它缓存清除掉此变量，当其它缓存B中的线程读取此变量时，会向总线发送消息，这是存储
新值的缓存A获取到消息，将新值传给B，最后将新值写入内存。

  * volatile的作用是被其修饰的变量每次刷新时，都会刷新上述步骤。

* （4）、volatile与synchronized

  1）volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞。

  2）volatile仅能使用在变量级别，synchronized则可以使用在变量、方法。

  3）volatile仅能实现变量修改的可见性，而synchronized则可以保证变量修改的可见性和原子性。《Java编程思想》上说，定义long或double时，如果使用volatile关键字(简单的赋值与返回操作)，就会获得原子性。(常规状态下，这两个变量由于其长度，其操作不是原子的)

  4）volatile不会造成线程阻塞，synchronized会造成线程阻塞。

  5）使用volatile而不是synchronized的唯一安全情况是类中只有一个可变的域。

* （5）、当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower<=upper的限制。

* （6）、使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。
	 4.JMM（java内存模型）
